const puppeteer = require('puppeteer');
const fs = require('fs');

// global constant, generated by getAccount.js
const { ACCOUNTS_LITS_PATH, CHECH_RESULT_PTAH } = require('./global');

const BATCH_SIZE = 50; // Process 50 addresses at a time.
const DELAY_BETWEEN_BATCHES = 60000; // Wait 1 minute between each batch.
// set a maximum runtime for your program and ensure it saves progress and exits gracefully
const MAX_TIME = 2 * 60 * 1000;
const startTime = new Date().getTime();

async function checkForPhishing(address, num) {
    // Launch Puppeteer with headless mode off for debugging
    const browser = await puppeteer.launch({
        headless: false, // Set to false so you can visually check if login or CAPTCHA is required
        executablePath: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
    });
    
    const page = await browser.newPage();
    
    // Set a custom User-Agent to avoid bot detection
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');

    // Navigate to the Etherscan page with networkidle2 to ensure full load
    await page.goto(`https://etherscan.io/address/${address}`, { waitUntil: 'networkidle2', timeout: 60000 });

    // Check if there's a CAPTCHA or login required
    const captchaExists = await page.$('div.recaptcha');
    const loginExists = await page.$('input[name="login"]');

    if (captchaExists) {
        console.log("CAPTCHA detected. You'll need to solve this manually.");
        await browser.close();
        return null;
    } else if (loginExists) {
        console.log("Login required. Automating login...");
        // Here you would add the code to handle login if required.
        await browser.close();
        return null;
    } else {
        console.log(`${num} - No CAPTCHA or login detected. Proceeding...`);
    }

    // Wait for the phishing/hack warning to appear
    try {
        await page.waitForSelector('span[class*="hash-tag"]', { timeout: 1 * 60 * 1000 });  // Wait up to 1 minutes to ensure the page fully loads.

        // Retrieve the phishing/hack warning text
        const warning = await page.evaluate(() => {
            const elements = document.querySelectorAll('span[class*="hash-tag"]');
            const matchingElement = Array.from(elements).find(el => el.textContent.includes('Phish / Hack'));
            return matchingElement ? matchingElement.textContent : null;
        });
        await browser.close();
        return warning ? 1 : 0;
       
        // console.log(warning ? `Warning: '${warning}' found for address ${address}.` : `No phishing warning found for address ${address}.`);
    } catch (error) {
        console.error("Error waiting for selector or timeout occurred:", error);
        await browser.close();
        return null;
    }

   
}

// Function to read addresses from the JSON file and check each for phishing
async function processAddresses() {
    // Read the JSON file
    const data = fs.readFileSync(ACCOUNTS_LITS_PATH, 'utf8');
    const addresses = JSON.parse(data);
    // Check accounts for verification.
    const results = []
    for (let i = 0; i < addresses.length; i += BATCH_SIZE) {
        const batch = addresses.slice(i, i + BATCH_SIZE);
        console.log(`Processing batch ${Math.floor(i / BATCH_SIZE) + 1}.`);
        let count = 0;
        for (const addressObj of batch) {
            count++;
            // check phishing
            const result = await checkForPhishing(addressObj.address, count);
            // save result
            results.push({
                address: addressObj.address,
                phishingStatus: result
            });
            const endTime = new Date().getTime();
            // set a maximum runtime for your program and ensure it saves progress and exits gracefully
            if(endTime - startTime > MAX_TIME) {
                fs.writeFileSync(`${CHECH_RESULT_PTAH}-${Math.floor(i / BATCH_SIZE) + 1}.json`, JSON.stringify(results, null, 2), 'utf8');
                return;
            }
        }
        // Save the final results to a file
        fs.writeFileSync(`${CHECH_RESULT_PTAH}-${Math.floor(i / BATCH_SIZE) + 1}.json`, JSON.stringify(results, null, 2), 'utf8');

        // Introduce a delay between batches to avoid triggering the website's rate limit
        await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
    }
}


processAddresses();


